trigger:
  branches:
    include:
    - branch-for-*
pr: none

variables:
  GH_CONNECTION: wheelwright
  REPO_DIR: checkout
  ARTIFACT_NAME: artifacts
  LINUX_TARGET: /io
  BUILD_DEPENDS: "-Ur checkout/requirements.txt"
  TEST_DEPENDS: "-Ur checkout/requirements.txt"
  PLAT: x86_64
  UNICODE_WIDTH: 32
  HOMEBREW_NO_AUTO_UPDATE: 1

jobs:
# - job: "sdist"
#   variables:
#     python.version: '3.8'
#   steps:
#   - task: UsePythonVersion@0
#     inputs:
#       versionSpec: '$(python.version)'
#       architecture: 'x64'

#   - bash: |
#       pip install -Ur ./requirements.txt
#       eval $(python ./run.py build-spec build-spec.json)
#       echo "##vso[task.setvariable variable=clone_url]$BUILD_SPEC_CLONE_URL"
#       echo "##vso[task.setvariable variable=package_name]$BUILD_SPEC_PACKAGE_NAME"
#       echo "##vso[task.setvariable variable=checkout]$REPO_DIR"
#       echo "##vso[task.setvariable variable=release_tag]$BUILD_SPEC_RELEASE_ID"
#     displayName: 'Set variables'

#   - script: |
#       git clone $(clone_url) $(checkout)
#       cd $(checkout)
#       python -m pip install -U pip
#       pip install -r requirements.txt
#       python setup.py sdist
#     displayName: 'Install and build sdist'

#   - bash: |
#       cd $(Build.SourcesDirectory)/$(checkout)
#       SDIST=$(python -c "import os;print(os.listdir('./dist')[0])" 2>&1)
#       pip install dist/$SDIST
#       rm -rf $(package_name)
#       python -m pytest --pyargs $(package_name)
#     displayName: 'Install from sdist & run tests'

#   - task: CopyFiles@2
#     inputs:
#       contents: '$(checkout)/dist/**'
#       targetFolder: $(Build.ArtifactStagingDirectory)
#       flattenFolders: true
#     displayName: 'Copy sdist'

#   - task: PublishBuildArtifacts@1
#     inputs:
#       pathtoPublish: $(Build.ArtifactStagingDirectory)
#       artifactName: '$(ARTIFACT_NAME)'
#     displayName: 'Publish sdist to artifacts'

#   - task: GitHubRelease@0
#     inputs:
#       gitHubConnection: '$(GH_CONNECTION)'
#       repositoryName: '$(Build.Repository.Name)'
#       action: 'edit'
#       tagSource: manual
#       tag: '$(release_tag)'
#       addChangeLog: false
#       assetUploadMode: replace
#       assets: '$(Build.ArtifactStagingDirectory)/*'
#     displayName: 'Upload to GitHub release'

- job: 'wheels'
  continueOnError: true
  strategy:
    matrix:
      # Python35Linux:
      #   imageName: 'ubuntu-16.04'
      #   python.version: '3.5'
      #   os: linux
      # Python35Windows:
      #   imageName: 'vs2017-win2016'
      #   python.version: '3.5'
      #   os: win
      # Python36Linux:
      #   imageName: 'ubuntu-16.04'
      #   python.version: '3.6'
      #   os: linux
      # Python36Windows:
      #   imageName: 'vs2017-win2016'
      #   python.version: '3.6'
      #   os: win
      # Python36Mac:
      #   imageName: 'macos-10.13'
      #   python.version: '3.6'
      #   os: osx
      # Python37Linux:
      #   imageName: 'ubuntu-16.04'
      #   python.version: '3.7'
      #   os: linux
      # Python37Windows:
      #   imageName: 'vs2017-win2016'
      #   python.version: '3.7'
      #   os: win
      # Python37Mac:
      #   imageName: 'macos-10.13'
      #   python.version: '3.7'
      #   os: osx
      # Python38Linux:
      #   imageName: 'ubuntu-16.04'
      #   python.version: '3.8'
      #   os: linux
      Python38Windows:
        imageName: 'vs2017-win2016'
        python.version: '3.8'
        os: win
      # Python38Mac:
      #   imageName: 'macos-10.13'
      #   python.version: '3.8'
      #   os: osx
    maxParallel: 4
  pool:
    vmImage: $(imageName)

  steps:
  - task: UsePythonVersion@0
    inputs:
      versionSpec: '$(python.version)'
      architecture: 'x64'

  - script: git submodule update --init --recursive
    displayName: 'Set up multibuild'

  - script: |
      # This is gettext needed for envsubst on osx =/
      brew install gettext
      brew link --force gettext
    condition: eq(variables['os'], 'osx')
    displayName: 'Before install (Mac)'

  # - task: PowerShell@2
  #   inputs:
  #     filePath: ./multibuild/install_python.ps1
  #   condition: eq(variables['os'], 'win')
  #   displayName: 'Install new Python if needed (Windows)'

  - script: |
      SET PATH=%PYTHON%;%PYTHON%\Scripts;%PATH%
      python -m pip install -U pip setuptools wheel virtualenv
    condition: eq(variables['os'], 'win')
    displayName: 'Before install (Windows)'

  - bash: |
      pip install -Ur ./requirements.txt
      eval $(python ./run.py build-spec build-spec.json)
      echo "##vso[task.setvariable variable=clone_url]$BUILD_SPEC_CLONE_URL"
      echo "##vso[task.setvariable variable=package_name]$BUILD_SPEC_PACKAGE_NAME"
      echo "##vso[task.setvariable variable=commit]$BUILD_SPEC_COMMIT"
      echo "##vso[task.setvariable variable=release_tag]$BUILD_SPEC_RELEASE_ID"
      echo "##vso[task.setvariable variable=checkout]$REPO_DIR"
      echo "##vso[build.updatebuildnumber]$BUILD_SPEC_RELEASE_ID"
    displayName: 'Set variables'

  - script: |
      pip install virtualenv
      git clone $(clone_url) $(checkout)
      export BUILD_COMMIT=$(commit)
      export PACKAGE_NAME=$(package_name)
      cat config.sh.template | envsubst > config.sh
    condition: or(eq(variables['os'], 'osx'), eq(variables['os'], 'linux'))
    displayName: 'Install (Mac / Linux)'

  - task: CopyFiles@2
    # This is hard-coded in the Docker scripts for Linux
    inputs:
      contents: '/**'
      targetFolder: $LINUX_TARGET
    condition: eq(variables['os'], 'linux')
    displayName: 'Copy multibuild files (Linux)'

  - script: |
      export MB_PYTHON_VERSION=$(python.version)
      export TRAVIS_PYTHON_VERSION=$(python.version)
      export TRAVIS_OS_NAME=$(os)
      export BUILD_COMMIT=$(commit)
      source $(Build.SourcesDirectory)/multibuild/common_utils.sh
      source $(Build.SourcesDirectory)/multibuild/travis_steps.sh
      before_install
      clean_code $(checkout) $(commit)
      export CONFIG_PATH=$LINUX_TARGET/config.sh
      export MULTIBUILD_DIR=multibuild
      build_wheel $(checkout) $PLAT
      install_run $PLAT
    condition: or(eq(variables['os'], 'osx'), eq(variables['os'], 'linux'))
    displayName: 'Build wheel (Mac / Linux)'

  - script: |
      git clone $(clone_url) $(checkout)
      cd $(checkout)
      git checkout $(commit)
      pip install -Ur requirements.txt
      python setup.py bdist_wheel
    condition: eq(variables['os'], 'win')
    displayName: 'Install and build wheel (Windows)'

  - task: PythonScript@0
    inputs:
      scriptSource: inline
      script: |
        # https://github.com/pypa/pip/issues/6951
        import os
        wheel_file = os.listdir('./dist')[0]
        wheel_path = os.path.join('./dist', wheel_file)
        os.rename(wheel_path, wheel_path.replace("cp38m-win", "cp38-win"))
        print(os.listdir('./dist'))
      failOnStderr: true
      workingDirectory: '$(Build.SourcesDirectory)/$(checkout)'
    condition: and(eq(variables['os'], 'win'), eq(variables['python.version'], '3.8'))
    displayName: Fix wheel name (Windows, Python 3.8)

  - bash: |
      cd $(Build.SourcesDirectory)/$(checkout)
      ls
      WHEEL=$(python -c "import os;print(os.listdir('./dist')[0])" 2>&1)
      pip install dist/$WHEEL
      rm -rf $(package_name)
      python -m pytest --pyargs $(package_name)
    condition: eq(variables['os'], 'win')
    displayName: 'Test wheel (Windows)'

  - task: CopyFiles@2
    inputs:
      contents: 'checkout/dist/**'
      targetFolder: $(Build.ArtifactStagingDirectory)
      flattenFolders: true
    condition: eq(variables['os'], 'win')
    displayName: 'Copy wheel (Windows)'

  - task: CopyFiles@2
    inputs:
      contents: 'wheelhouse/**'
      targetFolder: $(Build.ArtifactStagingDirectory)
      flattenFolders: true
    condition: or(eq(variables['os'], 'osx'), eq(variables['os'], 'linux'))
    displayName: 'Copy wheel (Mac / Linux)'

  - task: PublishBuildArtifacts@1
    inputs:
      pathtoPublish: $(Build.ArtifactStagingDirectory)
      artifactName: '$(ARTIFACT_NAME)'
    displayName: 'Publish artifact'

  - task: GitHubRelease@0
    inputs:
      gitHubConnection: '$(GH_CONNECTION)'
      repositoryName: '$(Build.Repository.Name)'
      action: 'edit'
      tagSource: manual
      tag: '$(release_tag)'
      addChangeLog: false
      assetUploadMode: replace
      assets: '$(Build.ArtifactStagingDirectory)/*'
    displayName: 'Upload to GitHub release'
